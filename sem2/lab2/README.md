# Класс ApplicationView

Класс `ApplicationView` отвечает за визуализацию данных и взаимодействие с пользователем с помощью Tkinter. Ниже приводится описание всех его методов.

---

## 1. Инициализация и настройка

### `__init__(self, table_values: list[tuple[str,str,str,str,str,int]] = "") -> None`
- **Назначение:**  
  Создаёт главное окно приложения, инициализирует переменные, строит таблицу и панели кнопок.
- **Параметры:**  
  - `table_values` — начальный список записей для отображения (кортежи из полей преподавателя).
- **Действия:**  
  1. Создаёт окно `Tk()`, задаёт заголовок, размер и запрет на изменение размеров.  
  2. Вызывает `set_vars()` для инициализации `StringVar`/`IntVar`.  
  3. Строит таблицу с помощью `table_creation(...)`.  
  4. Создаёт нижнюю панель кнопок через `buttons_creation()`.

---

## 2. Обработка открытия файлов

### `new_bz(self, file_path)`
- **Назначение:**  
  Проксирует вызов колбэка для открытия SQLite-файла.
- **Параметры:**  
  - `file_path` — путь к файлу.

### `new_xml(self, file_path)`
- **Назначение:**  
  Проксирует вызов колбэка для открытия XML-файла.
- **Параметры:**  
  - `file_path` — путь к файлу.

### `open_file(self)`
- **Назначение:**  
  Диалог выбора файла и автоматическое определение его типа (SQLite или XML).
- **Алгоритм:**  
  1. Запрашивает путь через `filedialog.askopenfilename()`.  
  2. Если файл выбран, читает первые 16 байт и по заголовку определяет тип:  
     - SQLite (`b"SQLite format 3\x00"`) → вызывает `new_bz`.  
     - XML (наличие `<?xml` или `<root`) → вызывает `new_xml`.  
     - Иначе — показывает сообщение об ошибке.

---

## 3. Построение и обновление таблицы

### `table_creation(self, values, container, height=0, find=False) -> ttk.Treeview`
- **Назначение:**  
  Строит виджет `Treeview` с данными, кнопками навигации и контролем количества строк на странице.
- **Параметры:**  
  - `values` — список записей (кортежей).  
  - `container` — контейнер (окно или фрейм) для размещения.  
  - `height` — смещение по вертикали (для поиска).  
  - `find` — флаг режима “поиска” (управление данными и навигацией по отдельному списку).
- **Действия:**  
  1. Задаёт колонки: факультет, кафедра, ФИО, звание, степень, стаж.  
  2. Создаёт `Frame` и `Treeview`, настраивает заголовки и выравнивание.  
  3. Добавляет фрейм с кнопками: «Первая», «Предыдущая», «Следующая», «Последняя»; ввод числа записей на страницу.  
  4. В режиме поиска работает с `self.find_result`.  
  5. Вызывает `update_view()` для отрисовки первой страницы.

### `update_table(self, table_values: list[tuple], find=False) -> None`
- **Назначение:**  
  Обновляет таблицу новыми данными (обычными или результатами поиска).
- **Параметры:**  
  - `table_values` — список кортежей для отображения.  
  - `find` — флаг режима поиска.
- **Действия:**  
  1. Сохраняет данные в `self.table_val` или `self.find_result`.  
  2. Сбрасывает текущую страницу на 1.  
  3. Вызывает `update_view()`.

---

## 4. Логика назначения переменных и получения данных

### `set_vars(self) -> None`
- **Назначение:**  
  Инициализирует все переменные `StringVar` и `IntVar` для полей ввода и управления страницами.
- **Переменные:**  
  - `self.faculty`, `self.department_name`, … — поля преподавателя.  
  - `self.per_page` — строк на страницу (по умолчанию 10).  
  - `self.current_page` — текущая страница (по умолчанию 1).

### `change_per_page(self, values, table) -> None`
- **Назначение:**  
  Изменяет число записей на страницу по введённому значению.
- **Алгоритм:**  
  1. Читает из `self.per_page_var`.  
  2. Если в диапазоне (1–23), обновляет `self.per_page` и сбрасывает страницу.  
  3. Иначе — показывает сообщение об ошибке.

### `get_total_pages(self, values) -> int`
- **Назначение:**  
  Вычисляет общее число страниц.
- **Возвращает:**  
  `max(1, ceil(len(values) / self.per_page))`.

### `update_view(self, values, table) -> None`
- **Назначение:**  
  Перерисовывает текущую страницу таблицы.
- **Алгоритм:**  
  1. Очищает `table`.  
  2. Вычисляет диапазон записей `start:end`.  
  3. Вставляет записи на страницу.  
  4. Обновляет лейбл `self.page_info` с информацией о странице.

### Навигационные методы
- `go_first(self, values, table)` — перейти на первую страницу.  
- `go_prev(self, values, table)` — предыдущая (если есть).  
- `go_next(self, values, table)` — следующая (если есть).  
- `go_last(self, values, table)` — последняя страница.  
- Все они меняют `self.current_page` и вызывают `update_view()`.

---

## 5. “Листовое” отображение

### `leaf_display(self) -> None`
- **Назначение:**  
  Открывает дерево (TreeView) “Факультет → Кафедра → Преподаватель → Детали”.
- **Алгоритм:**  
  1. Формирует список словарей `teachers` из `self.table_val`.  
  2. Создаёт окно `Toplevel`.  
  3. Строит `ttk.Treeview`: для каждого преподавателя  
     - если факультет новый — создаёт узел,  
     - если кафедра новая — создаёт внутри факультета,  
     - добавляет ФИО как лист, а затем подузел с текстом “степень, звание, стаж”.  
  4. Добавляет кнопку “Выйти” для закрытия.

---

## 6. Окна для CRUD-операций

### `new_add_window(self) -> None`
- **Назначение:**  
  Открывает окно добавления новой записи.
- **Алгоритм:**  
  1. Окно `Toplevel`, инструкция по заполнению.  
  2. Поля ввода для каждого атрибута преподавателя.  
  3. Кнопки “Добавить” (вызывает `add`) и “Выход” (закрытие).  
  4. Ожидание закрытия окна (`wait_window`).

### `add(self) -> None`
- **Назначение:**  
  Считывает введённые данные, вызывает колбэк `self.add_callback`, закрывает окно.
- **Особенность:**  
  Оборачивает в `try/except` для проверки числа в поле стажа.

### `new_delete_window(self) -> None`
- **Назначение:**  
  Открывает окно удаления по условию.
- **Алгоритм:**  
  1. Строит общую панель через `new_df_window()`.  
  2. Кнопки “Удалить” (вызывает `delete`) и “Выход”.  
  3. Ждёт закрытия.

### `delete(self) -> None`
- **Назначение:**  
  Собирает параметры (тип поиска и два поля), передаёт в `self.delete_callback`.

### `new_find_window(self) -> None`
- **Назначение:**  
  Открывает окно поиска с постраничным выводом.
- **Алгоритм:**  
  1. Строит панель через `new_df_window()`.  
  2. Инициализирует `self.find_result` и вызывает `table_creation(..., find=True)`.  
  3. Кнопки “Найти” (вызывает `find`) и “Выход”.  
  4. Ждёт закрытия.

### `find(self) -> None`
- **Назначение:**  
  Считывает параметры поиска и передаёт в `self.find_callback`.

### `new_df_window(self) -> tuple[Toplevel, Frame]`
- **Назначение:**  
  Универсальная конструкция для окон поиска/удаления:  
  - комбо-бокс с выбором типа условия,  
  - два поля ввода,  
  - фрейм для кнопок.
- **Возвращает:**  
  Кортеж `(окно, фрейм_для_кнопок)`.

---

## 7. Вспомогательные методы

### `buttons_creation(self) -> None`
- **Назначение:**  
  Создаёт нижнюю панель основных кнопок:  
  - Добавить, Удалить, Найти, Древо, Открыть файл, Выйти.

### `set_callbacks(self, add_func, delete_func, find_func, exit_func, xml_func, bz_func) -> None`
- **Назначение:**  
  Передаёт контроллерные функции (колбэки) в представление и связывает выход с `exit_func`.

### `correct_exit(self) -> None`
- **Назначение:**  
  Вызывает колбэк `self.exit_callback` при нажатии “Выйти” или закрытии окна.

### `message(self, message: str) -> None`
- **Назначение:**  
  Выводит информационное или ошибочное окно через `showinfo`.

### `run(self) -> None`
- **Назначение:**  
  Запускает главный цикл Tkinter: `mainloop()`.

// Controller.md

# Класс Controller

Класс `Controller` служит связующим звеном между моделью (`Model`) и представлением (`View`), обрабатывает пользовательские события и обеспечивает синхронизацию данных.

---

## 1. Инициализация контроллера

### `__init__(self, model, view)`

- **Назначение:**  
  Создаёт экземпляр контроллера, сохраняет ссылки на модель и представление, настраивает колбэки и заполняет начальную таблицу.

- **Параметры:**  
  - `model` — объект класса `Model`, отвечающий за работу с данными.  
  - `view` — объект класса `ApplicationView`, отвечающий за UI.

- **Алгоритм действий:**  
  1. Сохраняет `self.model = model` и `self.view = view`.  
  2. Вызывает `view.set_callbacks(...)`, передавая методы контроллера:  
     - `add` — добавление записи,  
     - `delete` — удаление,  
     - `find` — поиск,  
     - `correct_exit` — корректное завершение,  
     - `new_xml` — загрузка из XML,  
     - `new_bz` — загрузка из SQLite.  
  3. Загружает список преподавателей из модели: `self.model.teachers` и обновляет таблицу:  
     ```python
     self.view.update_table(self.model.teachers)
     ```

---

## 2. Добавление записи

### `add(self, new_line: tuple[str, str, str, str, str, int]) -> None`

- **Назначение:**  
  Добавляет нового преподавателя в хранилище.

- **Параметры:**  
  - `new_line` — кортеж из 6 элементов:  
    1. Факультет (str)  
    2. Кафедра (str)  
    3. ФИО преподавателя (str)  
    4. Учёное звание (str)  
    5. Учёная степень (str)  
    6. Стаж работы (int)

- **Алгоритм действий:**  
  1. Вызывает `self.model.add(new_line)` для добавления в базу/список.  
  2. Если всё прошло как надо, то переходит к пункту три c оповещением о успешности действия. Иначе, выводит пользователю сообщение об ошибке.
  3. Обновляет отображение:  
     ```python
     self.view.update_table(self.model.teachers)
     ```

---

## 3. Удаление записей

### `delete(self, del_conditions: list[str, str, str]) -> None`

- **Назначение:**  
  Удаляет одну или несколько записей по заданным параметрам.

- **Параметры:**  
  - `del_conditions` — список из трёх строк:  
    1. Тип условия (например, "ФИО преподавателя и/или кафедра")  
    2. Первое значение (или нижний предел)  
    3. Второе значение (или верхний предел)

- **Алгоритм действий:**  
  1. Вызывает `self.model.delete(del_conditions)` для удаления из базы.  
  2. Если всё прошло как надо, то переходит к пункту три c оповещением о успешности действия. Иначе, выводит пользователю сообщение об ошибке.
  3. Обновляет представление:  
     ```python
     self.view.update_table(new_table_values)
     ```

---

## 4. Поиск записей

### `find(self, find_conditions: list[str, str, str]) -> None`

- **Назначение:**  
  Выполняет поиск преподавателей по заданным критериям.

- **Параметры:**  
  - `find_conditions: list[str, str, str]` — список параметров, аналогичный `del_conditions: list[str, str, str]`.

- **Алгоритм действий:**  
  1. Вызывает `results = self.model.find(find_conditions)`. 
  2. Если всё прошло как надо, то переходит к пункту 3. Иначе, выводит пользователю сообщение об ошибке.
  3. Передаёт результат в представление в режиме поиска:  
     ```python
     self.view.update_table(results, find=True)
     ```

---

## 5. Загрузка данных из файлов

### `new_xml(self, file_path: str) -> None`

- **Назначение:**  
  Загружает данные из XML-файла.

- **Параметры:**  
  - `file_path` — путь к XML.

- **Алгоритм действий:**  
  1. Вызывает `self.model.new_xml(path)`.  
  2. Если всё прошло как надо, то переходит к пункту три. Иначе, выводит пользователю сообщение об ошибке. 
  3. Обновляет таблицу: `self.view.update_table(self.model.teachers)`.

### `new_bz(self, file_path: str) -> None`

- **Назначение:**  
  Загружает данные из SQLite-базы.

- **Параметры:**  
  - `file_path` — путь к .db или .sqlite.

- **Алгоритм действий:**  
  1. Вызывает `self.model.model.new_bz(path)`.  
  2. Если всё прошло как надо, то переходит к пункту три. Иначе, выводит пользователю сообщение об ошибке. 
  3. Обновляет представление.

---

## 6. Корректное завершение работы

### `correct_exit(self) -> None`

- **Назначение:**  
  Закрывает приложение через `self.model.exit()`.

- **Алгоритм действий:**  
  ```python
  self.model.exit()
  
# Класс Model

Класс `Model` отвечает за хранение и управление списком преподавателей, загрузку/сохранение данных в SQLite и XML, а также за базовые CRUD-операции.

---

## 1. Инициализация

### `__init__(self)`

- **Назначение:**  
  Создаёт или открывает локальную SQLite-базу `my_database.db`, гарантирует наличие таблицы `teachers` и загружает из неё все записи в память.

- **Алгоритм действий:**  
  1. Устанавливает атрибут `self.path = "my_database.db"` и флаг `self.xml = False`.  
  2. Открывает соединение с SQLite:  
     ```python
     connection = sqlite3.connect(self.path)
     cursor = connection.cursor()
     ```  
  3. Создаёт таблицу `teachers`, если она не существует:  
     ```sql
     CREATE TABLE IF NOT EXISTS teachers (
       "Факультет" TEXT,
       "Название кафедры" TEXT,
       "ФИО преподавателя" TEXT,
       "Учёное звание" TEXT,
       "Учёная степень" TEXT,
       "Стаж работы" INTEGER
     )
     ```  
  4. Выполняет `SELECT * FROM teachers` и сохраняет результат в `self.teachers`.  
  5. Закрывает соединение.

---

## 2. Загрузка из SQLite

### `new_bz(self, path) -> str`

- **Назначение:**  
  Переключается в режим чтения из базы и загружает файл `path` в память, до этого гарантируя сохранение предыдущих данных.

- **Параметры:**  
  - `path` — путь к файлу базы.

- **Алгоритм действий:**  
  1. Если ранее был загружен XML (`self.xml == True`), вызывается `self.xml_entry()` для сохранения изменений, иначе `self.bz_entry()`.  
  2. Сбрасывает флаг `self.xml = False` и обновляет `self.path = path`.  
  3. Читает содержимое новой базы через `self.bz_reading()`.  
  4. Возвращает результат проверки корректности данных `self.check(self.teachers)` (пустая строка — ошибок нет).

### `bz_reading(self)`

- **Назначение:**  
  Считывает все записи из текущей базы `self.path` в `self.teachers`.

- **Алгоритм действий:**  
  1. Открывает соединение к `self.path`, выполняет `SELECT * FROM teachers`.  
  2. Сохраняет выборку в `self.teachers`, закрывает соединение.

### `bz_entry(self)`

- **Назначение:**  
  Сохраняет текущий список `self.teachers` в базу `self.path`.

- **Алгоритм действий:**  
  1. Открывает соединение, удаляет все строки из таблицы: `DELETE FROM teachers`.  
  2. Вставляет все записи из `self.teachers` через `executemany`.  
  3. Коммит и закрытие.

---

## 3. Загрузка из XML

### `new_xml(self, path) -> str`

- **Назначение:**  
  Переключается в режим XML и загружает данные из XML-файла.

- **Параметры:**  
  - `path` — путь к XML.

- **Алгоритм действий:**  
  1. Сохраняет предыдущие данные (`self.xml_entry()` или `self.bz_entry()`).  
  2. Устанавливает `self.xml = True`, `self.path = path`.  
  3. Вызывает `self.xml_reading()` для парсинга.  
  4. Возвращает результат `self.check(self.teachers)`.

### `xml_reading(self)`

- **Назначение:**  
  С помощью SAX-парсера (`TeacherHandler`) считывает все записи из XML в `self.teachers`.

- **Алгоритм действий:**  
  1. Создаёт `xml.sax.make_parser()`, регистрирует `TeacherHandler`.  
  2. Парсит файл `self.path`.  
  3. После окончания парсинга сохраняет `handler.teachers` в `self.teachers`.

### `xml_entry(self)`

- **Назначение:**  
  Экспортирует текущие `self.teachers` обратно в XML-документ по пути `self.path`.

- **Алгоритм действий:**  
  1. Парсит существующий XML через `minidom.parse(self.path)`.  
  2. Удаляет все дочерние узлы из корня.  
  3. Для каждого кортежа преподавателя создаёт элемент `<Преподаватель>` с шестью подэлементами:  
     `"Факультет"`, `"Кафедра"`, `"ФИО"`, `"УчёнаяСтепень"`, `"УчёноеЗвание"`, `"Стаж"`.  
  4. Сохраняет документ: `doc.writexml(...)`.

---

## 4. Валидация данных

### `check(self, values: list[tuple]) -> str`

- **Назначение:**  
  Проверяет список записей на корректность типов и допустимые значения полей.

- **Параметры:**  
  - `values` — список кортежей по той же схеме, что таблица.

- **Алгоритм действий:**  
  1. Итерирует по каждой `line` в `values`.  
  2. Проверяет типы: первые пять — `str`, шестой — `int`.  
  3. Проверяет, что звание начинается с «Кандидат» или «Доктор» и оканчивается «наук».  
  4. Проверяет степень: только «Доцент» или «Профессор».  
  5. Проверяет стаж: `0 ≤ стаж ≤ 100`.  
  6. Возвращает текст ошибки при первом нарушении, иначе пустую строку.

---

## 5. CRUD-операции в памяти

### `add(self, new_line: tuple) -> (list, str)`

- **Назначение:**  
  Добавляет одну запись в `self.teachers`, если она проходит проверку и не дублирует существующую.

- **Параметры:**  
  - `new_line` — кортеж из 6 полей.

- **Алгоритм действий:**  
  1. Вызывает `self.check([new_line])`.  
  2. Проверяет на дубликат по первым пяти полям.  
  3. Если ошибок нет, добавляет в `self.teachers`.  
  4. Возвращает `(self.teachers, txt)` где `txt` — сообщение об ошибке или пустая строка.

### `delete(self, line: list[str]) -> (list, list)`

- **Назначение:**  
  Удаляет из `self.teachers` все записи, подходящие под условие.

- **Параметры:**  
  - `line` — `[тип_условия, arg1, arg2]`. Возможные типы:  
    - `"ФИО преподавателя и/или наименование кафедры"`  
    - `"Учёное звание и факультет"`  
    - Диапазон стажа.

- **Алгоритм действий:**  
  1. В зависимости от `line[0]` фильтрует `self.teachers`.  
  2. Удаляет совпадающие записи, собирает их в `deleted_lines`.  
  3. Возвращает `(self.teachers, deleted_lines)`.

### `find(self, line: list[str]) -> list`

- **Назначение:**  
  Ищет и возвращает все записи, соответствующие условию (по аналогии с `delete`, но без удаления).

- **Возвращает:**  
  - Список найденных кортежей.

---

## 6. Корректное завершение

### `correct_exit(self)`

- **Назначение:**  
  При выходе пользователя сохраняет данные обратно в последнем режиме (XML или SQLite).

- **Алгоритм действий:**  
  ```python
  if self.xml:
      self.xml_entry()
  else:
      self.bz_entry()


# Класс TeacherHandler

Класс `TeacherHandler` реализует SAX-парсер для чтения XML-файла с данными преподавателей и преобразует их в список кортежей.

---

## 1. Инициализация

### `__init__(self)`

- **Назначение:**  
  Готовит структуры для накопления информации при разборе XML.

- **Алгоритм действий:**  
  1. `super().__init__()`
  1. `self.teachers = []` — список результата.  
  2. `self.current_teacher = {}` — временный словарь для полей одного преподавателя.  
  3. `self.current_data = ''` — имя текущего тега.

---

## 2. Обработка начала тега

### `startElement(self, name, attrs)`

- **Назначение:**  
  Вызывается при чтении начала любого XML-тега.

- **Параметры:**  
  - `name` — имя тега.  
  - `attrs` — атрибуты (не используются).

- **Алгоритм действий:**  
  1. Если `name == 'Преподаватель'`, сбрасывает `self.current_teacher = {}`.  
  2. Устанавливает `self.current_data = name`, чтобы запоминать, в каком элементе находится парсер.

---

## 3. Чтение содержимого тега

### `characters(self, content)`

- **Назначение:**  
  Вызывается при чтении текстового содержимого внутри тега.

- **Параметры:**  
  - `content` — часть текста.

- **Алгоритм действий:**  
  1. Если `self.current_data` в списке:  
     `['Факультет','Кафедра','ФИО','УчёнаяСтепень','УчёноеЗвание','Стаж']`,  
     добавляет `content.strip()` к `self.current_teacher[self.current_data]`.

---

## 4. Обработка конца тега

### `endElement(self, name)`

- **Назначение:**  
  Вызывается при закрытии тега.

- **Параметры:**  
  - `name` — имя тега.

- **Алгоритм действий:**  
  1. Если `name == 'Преподаватель'`, формирует кортеж в порядке  
     `(faculty, department, fio, degree, title, experience)` из `self.current_teacher` и добавляет в `self.teachers`.  
  2. Приводит `experience` к `int`, при ошибке устанавливает `0`.  
  3. Сбрасывает `self.current_data = ''`.

---

## 5. Получение результатов

### `get_teachers(self) -> list[tuple]`

- **Назначение:**  
  Предоставляет разобранный результат внешнему коду (Model).

- **Возвращает:**  
  - Список кортежей `(Факультет, Название кафедры, ФИО, УчёнаяСтепень, УчёноеЗвание, Стаж работы)`.
